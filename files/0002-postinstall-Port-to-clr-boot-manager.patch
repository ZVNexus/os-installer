From 89e8baf5668166e3fdc80c764c5832ef788a0464 Mon Sep 17 00:00:00 2001
From: Ikey Doherty <ikey@solus-project.com>
Date: Mon, 27 Mar 2017 18:43:47 +0100
Subject: [PATCH 02/33] postinstall: Port to clr-boot-manager

Much of the manual configuration butchering is removed, as clr-boot-manager
is now responsible for all the heavy lifting when it comes to the kernel
and boot loader management.

The installer continues (for now) to install the bootloader initially,
however for UEFI this job will become CBM's in the future. For GRUB we
continue to edit the GRUB_BACKGROUND dynamically so that we have some kind
of styling regardless of the boot topology.

The important thing is, we no longer are responsible for the target cmdline
used, nor do we copy and kernel blobs anymore.

Signed-off-by: Ikey Doherty <ikey@solus-project.com>
---
 os_installer2/postinstall.py | 148 ++++++++++---------------------------------
 1 file changed, 35 insertions(+), 113 deletions(-)

diff --git a/os_installer2/postinstall.py b/os_installer2/postinstall.py
index 98a6c99..d100e69 100644
--- a/os_installer2/postinstall.py
+++ b/os_installer2/postinstall.py
@@ -575,7 +575,6 @@ class PostInstallFstab(PostInstallStep):
 
         appends = []
 
-        dev_path = self.info.strategy.drive.path
         ext4_ops = "rw,relatime,errors=remount-ro"
 
         # Add the ESP to /boot/efi
@@ -713,9 +712,6 @@ class PostInstallBootloader(PostInstallStep):
                 not self.is_lvm2_install()):
             return True
 
-        # Default options
-        options = "quiet splash"
-
         write_splash = False
         if os.path.exists("/usr/share/backgrounds/splash.tga"):
             if self.is_lvm2_install():
@@ -734,15 +730,6 @@ class PostInstallBootloader(PostInstallStep):
                 print(e)
                 pass
 
-        # Set the LUKS Container UUID
-        if self.is_encrypted_install():
-            luks_uuid = self.get_luks_uuid()
-            options += " rd.luks.uuid={}".format(luks_uuid)
-
-        # Add the resume from swap parameter if necessary
-        if self.swap_uuid is not None:
-            options += " resume=UUID={}".format(self.swap_uuid)
-
         # Now, load in, rewrite as we go..
         lines = []
         ogrub = os.path.join(self.installer.get_installer_target_filesystem(),
@@ -752,11 +739,7 @@ class PostInstallBootloader(PostInstallStep):
                 for line in grub_input.readlines():
                     line = line.replace("\n", "").replace("\r", "").strip()
 
-                    # Have to provide rd.luks.uuid
-                    if "GRUB_CMDLINE_LINUX_DEFAULT=" in line:
-                        line = "GRUB_CMDLINE_LINUX_DEFAULT=\"{}\"".format(
-                            options)
-                    elif "GRUB_BACKGROUND=" in line and write_splash:
+                    if "GRUB_BACKGROUND=" in line and write_splash:
                         splash_path = "/boot/grub/splash.tga"
                         line = "GRUB_BACKGROUND=\"{}\"".format(splash_path)
                     lines.append(line)
@@ -768,29 +751,49 @@ class PostInstallBootloader(PostInstallStep):
             return False
         return True
 
+    def apply_boot_loader(self):
+        """ Invoke clr-boot-manager itself """
+        kdir = os.path.join(self.installer.get_installer_target_filesystem(),
+                            "etc/kernel/cmdline.d")
+        kresumefile = os.path.join(kdir, "10_resume.conf")
+
+        # Write out the resume= parameter for clr-boot-manager
+        if self.swap_uuid is not None:
+            if not os.path.exists(kdir):
+                try:
+                    os.makedirs(kdir, 00755)
+                    with open(kresumefile, "w") as kfile_output:
+                        swap = "resume=UUID={}".format(self.swap_uuid)
+                        kfile_output.write(swap)
+                except Exception as ex:
+                    self.set_errors("Error with kernel config: {}".format(ex))
+                    return False
+
+        cmd = "clr-boot-manager update"
+        if not self.run_in_chroot(cmd):
+            self.set_errors("Failed to update bootloader configuration")
+            return False
+        return True
+
     def apply_bios(self):
         """ Take the BIOS approach to bootloader configuration """
         if not self.info.bootloader_install:
-            return True
+            # Still need detecting from other distros
+            return self.apply_boot_loader()
         if not self.apply_bios_config():
             return False
         cmd = "grub-install --force \"{}\"".format(self.info.bootloader_sz)
         if not self.run_in_chroot(cmd):
             self.set_errors("Failed to install GRUB bootloader")
             return False
-
-        cmd = "grub-mkconfig -o /boot/grub/grub.cfg"
-        if not self.run_in_chroot(cmd):
-            self.set_errors("Failed to update GRUB bootloader configuration")
-            return False
-        return True
+        # Proxy back to CBM
+        return self.apply_boot_loader()
 
     def apply_uefi(self):
-        """ Take the UEFI approach to bootloader configuration """
-        bpath = self.installer.get_installer_target_filesystem()
-        root_part = self.info.strategy.get_root_partition()
-        uuid = get_part_uuid(root_part)
-
+        """ Take the UEFI approach to bootloader configuration
+            TODO: In future this will be managed by clr-boot-manager itself,
+            we're just ensuring that we write the EFI variables
+        """
         espt = self.installer.get_esp_target()
         ofile = os.path.join(self.get_efi_dir(espt),
                              "goofiboot/goofibootx64.efi")
@@ -823,74 +826,8 @@ class PostInstallBootloader(PostInstallStep):
         if not updated_uefi:
             self.set_errors("Failed to install goofiboot")
             return False
-
-        ldir = self.get_loader_dir(espt)
-        entfile = os.path.join(ldir, "loader.conf")
-        try:
-            with open(entfile, "w") as defconf:
-                defconf.write("timeout 4\ndefault solus\n")
-
-        except Exception as e:
-            self.set_errors("Cannot set default loader config: {}".format(e))
-            return False
-
-        soldir = os.path.join(ldir, "entries")
-        solfile = os.path.join(soldir, "solus.conf")
-        if not os.path.exists(soldir):
-            try:
-                os.makedirs(soldir)
-            except Exception as ex:
-                self.set_errors("Cannot create EFI dirs: {}".format(ex))
-                return False
-
-        # Now write our loader.config itself..
-        cmdline = "root=UUID={} quiet ro".format(uuid)
-        if self.is_encrypted_install():
-            cmdline += " rd.luks.uuid={}".format(self.get_luks_uuid())
-
-        # Resume from swap
-        if self.swap_uuid is not None:
-            cmdline += " resume=UUID={}".format(self.swap_uuid)
-
-        try:
-            with open(solfile, "w") as solconf:
-                conf = [
-                    "title Solus 1.2.1",
-                    "linux /solus/kernel",
-                    "initrd /solus/initramfs",
-                    "options {}".format(cmdline)
-                ]
-                solconf.write("\n".join(conf) + "\n")
-        except Exception as e:
-            self.set_errors("Cannot write config: {}".format(e))
-            return False
-
-        # /solus on the ESP
-        sdir = self.get_solus_dir(espt)
-        if not os.path.exists(sdir):
-            try:
-                os.makedirs(sdir)
-            except Exception as ex:
-                self.set_errors("Cannot create solus EFI dir: {}".format(e))
-                return False
-
-        kver = os.uname()[2]
-        kernel = os.path.join(bpath, "boot/kernel-{}".format(kver))
-        initrd = os.path.join(bpath, "boot/initramfs-{}.img".format(kver))
-        tkernel = os.path.join(sdir, "kernel")
-        tinitrd = os.path.join(sdir, "initramfs")
-
-        try:
-            if os.path.exists(tkernel):
-                os.remove(tkernel)
-            if os.path.exists(tinitrd):
-                os.remove(tinitrd)
-            shutil.copy(kernel, tkernel)
-            shutil.copy(initrd, tinitrd)
-        except Exception as e:
-            self.set_errors("Couldn't install kernel assets: {}".format(e))
-            return False
-        return True
+        # Proxy back to CBM
+        return self.apply_boot_loader()
 
     def get_ichild(self, root, child):
         t1 = os.path.join(root, child)
@@ -907,18 +844,3 @@ class PostInstallBootloader(PostInstallStep):
 
     def get_efi_dir(self, base):
         return self.get_ichild(base, "EFI")
-
-    def get_loader_dir(self, base):
-        return self.get_ichild(base, "loader")
-
-    def get_efi_boot_dir(self, base):
-        return self.get_ichild(self.get_efi_dir(base), "Boot")
-
-    def get_efi_boot_file(self, base):
-        return self.get_ichild(self.get_efi_boot_dir(base), "BOOTX64.EFI")
-
-    def get_loader_entries(self, base):
-        return self.get_ichild(self.get_loader_dir(base), "entries")
-
-    def get_solus_dir(self, base):
-        return self.get_ichild(base, "solus")
-- 
2.13.3

